= Arquillian Reporter image:https://travis-ci.org/arquillian/arquillian-reporter.svg["Build Status", link="https://travis-ci.org/arquillian/arquillian-reporter"]
:toc:

Arquillian reporter brings neat and comprehensive reports into Arquillian Universe.

= For testers

If the Reporter is not provided by any extension then to use the Arquillian Reporter in you test you just need to add this depchain dependency:

[source,xml]
----
<dependency>
    <groupId>org.arquillian.reporter</groupId>
    <artifactId>arquillian-reporter-depchain</artifactId>
    <version>${version.arquillian.reporter}</version>
    <type>pom</type>
</dependency>
----


into your pom.xml file.

= For developers of an Arquillian extension

Arquillian reporter offers you a possibility to create complex and structured reports from your Arquillian extension in an easy and a clean way.
To use it in your Arquillian extension use the same dependency chain that is stated above (`org.arquillian.reporter:arquillian-reporter-depchain`)


== Report

The main building blog is `Report` that consist of:

* name
* list of Entries
* list of other sub-reports

As an Entry you can use any information that match one of these types:

* String
* Key-value (where value is an Entry)
* File
* Link
* Table
* Graph

From the structure you can see that it allows you to build a huge number of combinations of a report information that can be transitively nested.
The best representation of the Report structure is a tree of one root report and its sub-reports. The root report is created automatically by Arquillian Reporter project and it represents the whole test execution.

image::docs/images/report-tree.jpg[report tree]

Content of other sub-reports depends on tools and extensions you use and have on your classpath.
The java class Report is a interface and it is not expected that you would have to provide you own implementation of the Report (but you can if you want - for more information see ....). For the basic purposes (that should be sufficient for you) there is a implementation called `BasicReport` and it contains exactly the same information that are listed above. For other purposes (mainly internal) there are also other Report implementations:

* Configuration
* Failure
* TestSuite
* TestClass
* TestMethod


== How to use it?

To add anything to the whole report you should use events provided by Arquillian Reporter. Payload of the event is an instance of a Report. Before you fire your first event containing report you should understand the structure that is internally used and also know how could you use builders and other features of Arquillian Reporter.

=== Merging & adding new reports

Arquillian Reporter provides several automatic operations to make your reporting easier and more independent. One of the operations is merging.

Arquillian Reporter is able to merge two Reports together so you don't have to complicatedly collect all information and then fire one event. Instead of that, you can fire several events continuously - you can notify immediately when you have some piece of report and let Reporter to merge (based on some information) the pieces together.
Another case is when you want to add some entry to a report that has been created by other extension or by Arquillian Reporter itself. You don't have to browse through the whole tree, you just fire an event with an appropriate information.

To make the merging possible, we need to somehow identify the nodes of the whole report tree. Because of complexity, it wasn't possible to identify all the nodes in the whole tree but only some of them. The whole Report tree is divided into several sections and only the root reports of the section are allowed to be merged.

==== Section

The whole Report tree is divided into several sections. There is one root section (called Execution Section) that contains the whole tree and some other subsections which can also contain additional subsections.
Every section is represented by an event class that implements interface `SectionEvent`. You can create your own section implementing this interface (for more information see ....) or you can reuse some of those that are already created.

Sections (events) that are already defined by Arquillian Reporter:

* TestSuiteSection
* TestSuiteConfigurationSection
* TestClassSection
* TestClassConfigurationSection
* TestMethodSection
* TestMethodConfigurationSection
* TestMethodFailureSection

Sections defined by Arquillian-core Reporter:

* TestSuiteConfigurationContainerSection
* TestClassConfigurationDeploymentSection

If we incorporated some of them into the report tree, it would look like this:

image::docs/images/reporter-sections.jpg[reports&sections]

and only the red one is possible to merge. The thing is that, these reports are fired using the event with a specified string(identifier). This identifier should be unique in the whole subsection.
Internally, Arquillian Reporter keeps an additional tree. It is a tree of the sections + identifier nodes (let's call it section tree). If we rewrote the tree into the section tree that is kept internally in memory it could look like this:

image::docs/images/sections.jpg[reports&sections]

there you can see that every node in the section tree is defined by a combination of the section-event-class + identifier. These nodes then keeps references to corresponding report instances in the report tree:

image::docs/images/references.jpg[reports&sections]

Then if you want to add some information to a config report related to browsers, you just fire an event TestClassConfigurationSection with an identifier `browser-config` and the attached Report. Arquillian Reporter then will find the existing report and add entries and sub-reports contained in the new report to the existing one.

==== How to identify the node

In the previous section we have described basics about sections and merging. You can certainly imagine that it can be sometimes quite difficult to match the correct report that should be merged.
Imagine this situation:

image::docs/images/multiple-deployments.jpg[multiple deployments tree]

there are several deployments with the same name (identifier) but used in different test classes. So, how I can merge the report about ear deployment used in the EapTestCase class? Every event (that represents some section) contains also an additional information that helps to identify a parent section the section belongs to. In other words, there in the TestClassConfigurationDeploymentSection class you may also define test class the deployment was defined in and also a test suite identifier. Arquillian Reporter then using method "getParentSectionThisSectionBelongsTo()" retrospectively create an expected path in the section tree:

image::docs/images/expected-path.jpg[expected path]

and tries to find the best candidate in the whole section tree. If there in the tree is already a section with corresponding identifier, then it merges the reports. If there isn't any, then it attaches a new one and the report contained in the the event adds into report tree.

===== Missing identifier of parental sections

In case that the section event doesn't contain all necessary information to match the specific nodes in the section tree (eg. missing identifier of the test class of test suite), then Arquillian Reporter takes the latest added node belonging into corresponding section (latest reporter test class).
Let's take the previous example. In case we didn't specify the test class the deployment was defined in, then the expected path would look like this:

image::docs/images/expected-path-latest.jpg[expected path]

Since there wouldn't be any identifier for TestClassSection set, then the latest report would be taken = WildFlyTestCase

=== Builders

To make your reporting easier there are available builders providing fluent API that helps you to create reports and entries and add reports into appropriate sections.
The main starting point is class `Reporter`, then you can decide what you want to build.

Available builders:

==== ReportBuilder
using this builder you can build a report. To do so, use the method:
[source,java]
----
Reporter.createReport()
----
There are three methods with this name but with different parameter. If you use one of these methods:
[source,java]
----
Reporter.createReport(String name)
Reporter.createReport(StringKey name)
----
then BasicReportBuilder is used and thus an instance of BasicReport is created (more about StringKey in this chapter). There are already several other builder created, but all of them has the same basic set of API methods.
To use one specific builder to create one specific report choose the method `createReport(Report report)` where as a parameter use an existing instance of a report. For example if you write:
[source,java]
----
Reporter.createReport(new TestClassReport("my report"));
----
then TestClassReportBuilder is used.

Useful report builders that are available:
* BasicReportBuilder
* TestSuiteReportBuilder
* TestClassReportBuilder
* TestMethodReportBuilder
* ConfigurationReportBuilderImpl
* FailureReportBuilderImpl

===== ReportBuilder API
Report builders provide you a fluent API that helps you to create a complex report. All methods returns the same instance of the builder so you can use fluent api and make your code more readable. To get the final instance of the report call the method:

[source,java]
----
Reporter.createReport(...)
        ....
        .build();
----
which returns you the resulting report instance.

Some other method examples (that are same for all report builders):

* To add a key-value pair entry into the set of entries:
[source,java]
----
Reporter.createReport(...).addKeyValueEntry(StringKey key, Entry value)
----

* To add any entry
[source,java]
----
Reporter.createReport(...).addEntry(Entry entry)
----

* To add a sub-report
[source,java]
----
Reporter.createReport(...).addReport(Report report)
----
or instead of passing an instance of a report you can pass an Instance of ReportBuilder without building it and build only the parental builder.
[source,java]
----
Reporter.createReport(...)
        .addReport(Reporter.createReport(..)....)
        .build();
----

===== Add into section

Now, when you have a an instance of a built report you would like to add it into the whole report tree. To do so, you should create an instance of an event that represents a section the report should belong to, set the report as a payload and then fire it. The standard code would look like:
[source,java]
----
ConfigurationReport report = Reporter
            .createReport(new ConfigurationReport("my report"))
            .build();
injectedReportEvent.fire(new TestClassConfigurationSection(report, "configId"));
----
instead of this, you can use method `inSection` provided by ReportBuilder API and keep everything compact:
[source,java]
----
Reporter
    .createReport(new ConfigurationReport("my report"))
    .inSection(new TestClassConfigurationSection("configId"))
    .fire(injectedReportEvent);
----
Reporter uses corresponding instance of report, builds it, sets it into the used section event and fires the event.

===== Type of the payload

As you have already noticed, every section event has defined some type of report that is its default payload type. For example TestMethodSection has TestMethodReport and TestMethodConfigurationSection has ConfigurationReport etc... These types are also defined in the constructors of the section event classes. However, using the ReportBuilder API you can make the section to carry any other type of report. You can do for example this:
[source,java]
----
Reporter
    .createReport("my report")
    .inSection(new TestClassSection(TestClass.class))
    .fire(injectedReportEvent);
----
This creates an instance of BasicReport and sets it into the TestClassSection event. This report is then added into the list of sub-reports of 'TestClassReport' related to defined 'TestClass.class'. Analogically it is treated with this use case:
[source,java]
----
Reporter
    .createReport(new ConfigurationReport("my config report"))
    .inSection(new TestClassSection(TestClass.class))
    .fire(injectedReportEvent);
----
In this use case, an instance of ConfigurationReport is used and added into the list of configuration sub-reports in  the 'TestClassReport' of the 'TestClass' class.

===== Automatic creation of missing section nodes

It may happen that you want to add subsection of some section that doesn't exist. In other words, in the section event that you fire you use an identifier that doesn't match any existing section node. Arquillian Reporter then creates missing section node with the identifier and also corresponding report node in the report tree. This report's name is equal to the identifier. Then the report that has been attached in the section event is added in this automatically created report as its sub-report.
This will guarantee that none of the reported information will be lost. Take a look at the chapter ... to see the real example of this function.

==== Entry builders

===== TableBuilder

Table builder provides you a fluent API that helps you to create complex table. To use the builder call one of the two methods:
[source,java]
----
Reporter.createTable(String name)
Reporter.createTable(StringKey name)
----
and to get an instance of the table entry use the method `build()`

=== Enough theory, give me some examples

We went through basics of the Arquillian Reporter functions, now here are some examples how to add your reports into the whole report tree.

Let say we have this structure of the report:

image::docs/images/first-in-steps.jpg[original structe tree]

now we would like to add an information that both the test class and the test method are marked to be run as a client (to add key-value entry runAsClient = true)

First of all we will add it into the test class report. Because we need to merge two reports we have to use TestClassReport (we can omit the name), then we can add key-value pair and fire using corresponding section event.
[source,java]
----
Reporter
    .createReport(new TestClassReport())
    .addKeyValueEntry("runAsClient", true)
    .inSection(new TestClassSection(WildFlyTestClass.class))
    .fire(injectedReportEvent);
----
and analogically for test method
[source,java]
----
Reporter
    .createReport(new TestMethodReport())
    .addKeyValueEntry("runAsClient", true)
    .inSection(new TestMethodSection())
    .fire(injectedReportEvent);
----
then the resulting trees structure would be same - only the information would change:

image::docs/images/steps-with-run-as-client.jpg[added runAsClient=false]

now I'd like to add information about container. There is already a section created for container related information - `TestSuiteConfigurationContainerSection` - whose default payload is BasicReport

[source,java]
----
Reporter
    .createReport("WildFly")
    .addKeyValueEntry("jbossHome", "/path/to/wildfly")
    .addKeyValueEntry("managed", "false")
    .inSection(new TestSuiteConfigurationContainerSection("WildFly"))
    .fire(injectedReportEvent);
----
Using the API I've just created an instance of BasicReport with the name "WildFly" and added some key-value entries. Then I set the report as a payload of TestSuiteConfigurationContainerSection event and fired the event.
TestSuiteConfigurationContainerSection is a subsection of TestSuiteConfigurationSection but in the graph you can see that there is no such a section-event-node present. In this case, the functionality described in the chapter <<Automatic creation of missing section nodes>> is used. Since TestSuiteConfigurationContainerSection identifies its parent in this way:
[source,java]
----
new TestSuiteConfigurationSection(testSuiteId, "containers");
----

then a new section node TestSuiteConfigurationSection with the identifier "containers" is created. The resulting trees then would like:

image::docs/images/steps-with-container.jpg[added container]

Next step is to add a new information to the TestMethodSection about Drone. I want to add that in this method a method-scoped instance of drone was used and the browser was Firefox.
[source,java]
----
Reporter
    .createReport("Drone report")
    .addKeyValueEntry("scope", "method")
    .addKeyValueEntry("browser", "Firefox")
    .inSection(new TestMethodSection(clientTest))
    .fire(injectedReportEvent);
----
I just want to add a basic report to the list of sub-reports - that's why I don't specify any specific type of report and let Arquillian Reporter create an instance of BasicReport. Then I set it as a payload to the TestMethodSection with the defined test method.
The section tree wouldn't change, but in the report tree would occur a new report node:

image::docs/images/steps-drone-report.jpg[added drone]

Analogically, we could continue with merging and adding new reports.

== String-keys

== Create your own report

== Create your own section

== Create your own builder










