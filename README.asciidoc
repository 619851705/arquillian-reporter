= Arquillian Reporter image:https://travis-ci.org/arquillian/arquillian-reporter.svg["Build Status", link="https://travis-ci.org/arquillian/arquillian-reporter"]
:toc:

Arquillian reporter brings neat and comprehensive reports into Arquillian Universe.

= For testers

If the Reporter is not provided by any extension then to use the Arquillian Reporter in you test you just need to add this depchain dependency:

[source,xml]
----
<dependency>
    <groupId>org.arquillian.reporter</groupId>
    <artifactId>arquillian-reporter-depchain</artifactId>
    <version>${version.arquillian.reporter}</version>
    <type>pom</type>
</dependency>
----


into your pom.xml file.

= For developers of an Arquillian extension

Arquillian reporter offers you a possibility to create complex and structured reports from your Arquillian extension in an easy and a clean way.


== Report

The main building blog is `Report` that consist of:

* name
* list of Entries
* list of other sub-reports

As an Entry you can use any information that match one of these types:

* String
* Key-value (where value is an Entry)
* File
* Link
* Table
* Graph

From the structure you can see that it allows you to build a huge number of combinations of a report information that can be transitively nested.
The best representation of the Report structure is a tree of one root report and its sub-reports. The root report is created automatically by Arquillian Reporter project and it represents the whole test execution.

image::docs/images/report-tree.jpg[report tree]

Content of other sub-reports depends on tools and extensions you use and have on your classpath.
The java class Report is a interface and it is not expected that you would have to provide you own implementation of the Report (but you can if you want - for more information see ....). For the basic purposes (that should be sufficient for you) there is a implementation called `BasicReport` and it contains exactly the same information that are listed above. For other purposes (mainly internal) there are also other Report implementations:

* Configuration
* Failure
* TestSuite
* TestClass
* TestMethod


== How to use it?

To add anything to the whole report you should use events provided by Arquillian Reporter. Payload of the event is an instance of a Report. Before you fire your first event containing report you should understand the structure that is internally used and also know how could you use builders and other features of Arquillian Reporter.

=== Merging & adding new reports

Arquillian Reporter provides several automatic operations to make your reporting easier and more independent. One of the operations is merging.

Arquillian Reporter is able to merge two Reports together so you don't have to complicatedly collect all information and then fire one event. Instead of that, you can fire several events continuously - you can notify immediately when you have some piece of report and let Reporter to merge (based on some information) the pieces together.
Another case is when you want to add some entry to a report that has been created by other extension or by Arquillian Reporter itself. You don't have to browse through the whole tree, you just fire an event with an appropriate information.

To make the merging possible, we need to somehow identify the nodes of the whole report tree. Because of complexity, it wasn't possible to identify all the nodes in the whole tree but only some of them. The whole Report tree is divided into several sections and only the root reports of the section are allowed to be merged.

==== Section

The whole Report tree is divided into several sections. There is one root section (called Execution Section) that contains the whole tree and some other subsections which can also contain additional subsections.
Every section is represented by an event class that implements interface `SectionEvent`. You can create your own section implementing this interface (for more information see ....) or you can reuse some of those that are already created.

Sections (events) that are already defined by Arquillian Reporter:

* TestSuiteSection
* TestSuiteConfigurationSection
* TestClassSection
* TestClassConfigurationSection
* TestMethodSection
* TestMethodConfigurationSection
* TestMethodFailureSection

Sections defined by Arquillian-core Reporter:

* TestSuiteConfigurationContainerSection
* TestClassConfigurationDeploymentSection

If we incorporated some of them into the report tree, it would look like this:

image::docs/images/reporter-sections.jpg[reports&sections]

and only the red one is possible to merge. The thing is that, these reports are fired using the event with a specified string(identifier). This identifier should be unique in the whole subsection.
Internally, Arquillian Reporter keeps an additional tree. It is a tree of the sections + identifier nodes (let's call it section tree). If we rewrote the tree into the section tree that is kept internally in memory it could look like this:

image::docs/images/sections.jpg[reports&sections]

there you can see that every node in the section tree is defined by a combination of the section-event-class + identifier. These nodes then keeps references to corresponding report instances in the report tree:

image::docs/images/references.jpg[reports&sections]

Then if you want to add some information to a config report related to browsers, you just fire an event TestClassConfigurationSection with an identifier `browser-config` and the attached Report. Arquillian Reporter then will find the existing report and add entries and sub-reports contained in the new report to the existing one.

==== How to identify the node

In the previous section we have described basics about sections and merging. You can certainly imagine that it can be sometimes quite difficult to match the correct report that should be merged.
Imagine this situation:

image::docs/images/multiple-deployments.jpg[multiple deployments tree]

there are several deployments with the same name (identifier) but used in different test classes. So, how I can merge the report about ear deployment used in the EapTestCase class? Every event (that represents some section) contains also an additional information that helps to identify a parent section the section belongs to. In other words, there in the TestClassConfigurationDeploymentSection class you may also define test class the deployment was defined in and also a test suite identifier. Arquillian Reporter then using method "getParentSectionThisSectionBelongsTo()" retrospectively create an expected path in the section tree:

image::docs/images/expected-path.jpg[expected path]

and tries to find the best candidate in the whole section tree. If there in the tree is already a section with corresponding identifier, then it merges the reports. If there isn't any, then it attaches a new one and the report contained in the the event adds into report tree.

===== Missing identifier of parental sections

In case that the section event doesn't contain all necessary information to match the specific nodes in the section tree (eg. missing identifier of the test class of test suite), then Arquillian Reporter takes the latest added node belonging into corresponding section (latest reporter test class).
Let's take the previous example. In case we didn't specify the test class the deployment was defined in, then the expected path would look like this:

image::docs/images/expected-path-latest.jpg[expected path]

Since there wouldn't be any identifier for TestClassSection set, then the latest report would be taken = WildFlyTestCase

=== Builders

To make your reporting easier there are available builders providing fluent API that helps you to create reports and entries and add reports into appropriate sections.
The main starting point is class `Reporter`, then you can decide what you want to build.

Available builders:

==== ReportBuilder
using this builder you can build a report. To do so, use the method:
[source,java]
----
Reporter.createReport()
----
There are three methods with this name but with different parameter. If you use one of these methods:
[source,java]
----
Reporter.createReport(String name)
Reporter.createReport(StringKey name)
----
then BasicReportBuilder is used and thus an instance of BasicReport is created (more about StringKey in this chapter). There are already several other builder created, but all of them has the same basic set of API methods.
To use one specific builder to create one specific report choose the method `createReport(Report report)` where as a parameter use an existing instance of a report. For example if you write:
[source,java]
----
Reporter.createReport(new TestClassReport("my report"));
----
then TestClassReportBuilder is used.

Useful report builders that are available:
* BasicReportBuilder
* TestSuiteReportBuilder
* TestClassReportBuilder
* TestMethodReportBuilder

===== ReportBuilder API
Report builders provide you a fluent API that helps you to create a complex report. All methods returns the same instance of the builder so you can use fluent api and make your code more readable. To get the final instance of the report call the method:

[source,java]
----
Reporter.createReport(...)
        ....
        .build();
----
which returns you the resulting report instance.

Some other method examples (that are same for all report builders):

* To add a key-value pair entry into the set of entries use
[source,java]
----
Reporter.createReport(...).addKeyValueEntry(StringKey key, Entry value)
----

* To add any entry use
[source,java]
----
Reporter.createReport(...).addEntry(Entry entry)
----

* To add a sub-report use
[source,java]
----
Reporter.createReport(...).addReport(Report report)
----
or instead of passing an instance of a report you can pass an Instance of ReportBuilder without building it and build only the parental builder.
[source,java]
----
Reporter.createReport(...)
        .addReport(Reporter.createReport(..)....)
        .build();
----

===== Add into section

Now, when you have a an instance of a built report you would like to add it into the whole report tree. To do so, you should create an instance of an event that represents a section the report should belong to, set the report as a payload and then fire it. The standard code would look like:
[source,java]
----
ConfigurationReport report = Reporter
            .createReport(new ConfigurationReport("my report"))
            .build();
injectedReportEvent.fire(new TestClassConfigurationSection(report, "configId"));
----
instead of this, you can use method `inSection` provided by ReportBuilder API and keep everything compact:
[source,java]
----
Reporter
    .createReport("my report")
    .inSection(new TestClassConfigurationSection("configId"))
    .fire(injectedReportEvent);
----
Reporter creates corresponding instance of report, set it into the used section event and fire the event.

==== Entry builders

===== TableBuilder

Table builder provides you a fluent API that helps you to create complex table. To use the builder call one of the two methods:
[source,java]
----
Reporter.createTable(String name)
Reporter.createTable(StringKey name)
----
and to get an instance of the table entry use the method `build()`

=== Enough theory, give me some examples

We went through basics of the Arquillian Reporter functions, now here are some examples how to add your reports into the whole report tree.

Let say we have this structure of the report:



==== Automatic creation of missing section nodes


== String-keys



== Create your own report

== Create your own section

== Create your own builder










